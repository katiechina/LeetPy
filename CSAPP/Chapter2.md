# 深入理解计算机系统（2）

- 深度参考 Datawhale CSAPP教程

## 一、 虚拟地址空间

字长（word size）决定虚拟地址空间的最大大小
- 64位字长的机器  0 ～ 2 ** 64-1 16EB
- 32位字长的机器  0 ～ 2 ** 32-1 4GB


程序将内存视为一个非常大的数组，每一个元素就是一个字长，每个字长由唯一的数字表示
- 独一无二的数字（一个字长） --> 地址（address） --> 所有地址集合 --> 虚拟地址空间 


- bit ： 1位二进制 （0 或 1）
- byte ： 8个bit，也即8个二进制位（8个 0或1）

大多数 64 位的机器做了向后兼容
- 程序 --> 在32位机器上编译 --> 可同时在32位和64位机器上运行
- 程序 --> 在64位机器上用32位编译 --> 可同时在32位和64位机器上运行 
- 程序 --> 在64位机器上用64位编译 --> 只能在64位机器上运行

## 二、 寻址和字节顺序
对int类型数字  0x01234567 占用4个字节，即32位二进制位
- 0x01 是 最高有效字节
- 0x67 是 最低有效字节

- 大端法 -- 最高有效字节存储在最前面，也就是低地址处
- 小端法 -- 最低有效字节存储在在最前面

|类型 | 值 | 十六进制 |
| --- | --- | --- |
| int | 12,345 | 0x00003039 |
| float | 12,345.0 | 0x00e44046 |

int类型和float类型编码完全不同

C 语言中的字符串被编码为以 NULL 字符结尾的字符数组
- abcde --> a b c d e null --> 61 62 63 64 65 00
- 总长度为 6
- 结尾字符的十六进制表示为 0x00，使用 ASCII 码来表示字符，在任何系统上都 会得到相同的结果。因此，文本数据比二进制数据具有更强的平台独立性。

## 三、 布尔运算
- 非   NOT  即取反
- 或   OR   一个为True，则都为True
- 与   AND  一个为False，则都为False
- 异或 EOR  相同为False，相反为True

C 语言中的一个特性就是支持按位进行布尔运算
- 位运算一个常见的用法就是实现掩码运算，通俗点讲，通过位运算可以得到特定的位序列。

- 如子网掩码中需要通过IP获取子网掩码，就可以通过位运算实现
- 以0x89ABCDEF为例，可以通过 & 0xFF，这样我们就得到了最低有效字节 0x000000EF
- 因为0xFF的二进制值为 00000000 0000000 00000000 11111111
- 按位进行与运算时，0与任何数与运算均为0，所以高位都为0， 1与其他值进行与运算时还是得到其他值，所以低位值不变，最后得到最低有效位

## 四、 逻辑运算
逻辑运算认为所有非零的参数都表示 true，只有参数 0 表示 false

运算结果：
- false 对应 0x00
- true  对应 0x01

- && 运算如果第一个参数为false， 直接返回false，不会计算后面的参数
- || 运算如果第一个参数为true，直接返回true，不会计算后面的参数

## 五、  数值信息的表示
在有 符号数的前面增加 1 位符号位，用 0 表示正号，用 1 表示负号。

### 原码
正数的符号位用“0”表示，负数的符号位用“1”表示，其余数位表示数值本身
对于 0，我们既可以认为是 +0，也可以认为是-0，因此它的原码并不唯一
[ +0 ]原=00000000 [ -0 ]原 =10000000

原码概念简单，为什么要引入反码和补码？
用原码表示的数在计算机中进行加减法运算很麻烦。比如遇到两个异号数相加或者两个同号数相减时，就要做减法。为了简化运算器的复杂性，提高运算速度，需要把减法做成加法运算，因此人们引入了反码和补码。


### 反码
- 正数的反码与其原码相同; 
- 负数的反码是在原码的基础上保持符号位不变，其余各位按位求反得到的。

X=+1010110, [X]反=[X]原=01010110.
Y=-0110101, [Y]原=10110101 [Y]反=11001010.

### 补码
- 正数的补码与其原码相同; 
- 负数的补码是在原码的基础上保持符号位不变，其它的数位 1 变为 0，0 变为 1，最后再加 1 运算。也就是说，负数的补码是它的反码加 1。
- 在计算机中，有符号整数常常用补码形式存储。

- 补码中 0 无正负之分，即 [+0]补=[-0]补=00000000
    X=+1010110 [X]补=[X]反=[X]原=01010110.
    Y=-0110101 [Y]原=10110101， [Y]反=11001010， [Y]补=11001011.

- 32位bit的有符号数据中
    补码可以代表的最小数是 -2 ** 31， 
    10000000 0000000 00000000 00000000
    可以代表的最大数是 2 ** 31-1
    01111111 11111111 11111111 11111111

### 强制类型转换
- -12345 经过强制类型转换后得到的无符号数是 53191
    -12345: 1100 11111100 0111
    53191: 1100 11111100 0111
    2 ** 16 - 12345 = 53191

- 有符号位转无符号
    当x是负数时，强制转换后的值 =  2 ** 总二进制位数 + x
    当x是正数时，强制转换后的值 =  x


- 无符号转有符号
    x为要转换的值
    x最高位为0时，强制转换后的值 =  x
    x最高位为1时，强制转换后的值 =  x -  2 ** 总二进制位数

- 在 C 语言中，在执行一个运算时，如果一个运算数是有符号数，另外一个运算数是 无符号数，那么 C 语言会隐式的将有符号数强制转换成无符号数来执行运算
    a = -1
    b = 0 (无符号位)
    a > b  (此时a被强制转位无符号位 4294967295 = 2 ** 32 − 1 )


- 无符号数转换成一个更大的数据类型只需要在扩展的数位进行补 0 即可

- 无符号数转换成一个更大的数据类型
    - x为要转换的数
    - x最高位为0时，与无符号类似，扩展的高位补0
    - x最高位为1时，此时扩展的数位需要进行补 1

### 截断
将 int 类型强制类型转换成 short 类型时，int 类型高 16 位数据被丢弃，留下低 16 位的数据，因此截断一个数字，可能会改变它原来的数值

- 无符号直接截断，也相当于去模运算，得到余数
    x % (2**16)

- 有符号位
    直接截断后根据最高位是0还是1，判断是正数还是负数，转换为有符号数


### 溢出
- unsigned char a = 255;
- unsigned char b = 1; 
- unsigned char c = a + b;

- 我们预期c是256，实际返回0
    因为char的长度是8位， 2 ** 8 = 256， 最大值只能取到256-1 = 255
    所以溢出了，如果要判断是否溢出，用 c>a 判断
    if c>a : 未溢出
    if c<a : 溢出


有符号数的溢出分为正溢出和负溢出。
- 当 x 加 y 的和大于等于 2w−1 时，发生正溢出，此时，得到的结果会减去 2 ** w
- 当 x 加 y 的和小于 −2w−1 时，发生负溢出，此时，得到的结果会加上 2 ** w

无符号位乘法：
(x * y) % (2 ** w)

以乘除 2 的倍数为例的运算规则
原码运算:
- 对于原码，不论正负，若某个数字乘 2w 的倍数，则只 需要对原码向左移动 w 个单位，空缺位补 0。
- 对于补码，正数则仍然按照原码规则进行计算，而负数则需要保证符号位不变，在向左移动时补 0，向右移动时补 1。例如:[-5]补=1011，将其乘以 2，则保持符号位最高的 1 不变，其余位置向左移动一个单位，空出来的最后侧加 0，则为 10110 =[-10]补

## 六、 浮点数的表示

V = (−1) ** s × M × 2 ** E

- 32位单精度浮点数
C 语言中 float 类型的变量占 4 个字节，32 个比特位，这 32 个比特位被划分成 3 个字段来解释。

最高位 31 位表示符号位 s： 0 代表正数，1代表负数
从第 23 位到 30 位，这 8 个二进制位与阶码的值 E 是相关的。
剩余的 23 位与尾数 M 是相关的。

- 64位双精度浮点数
双精度浮点数的符号位也是 1 位：
    最高位 63 位表示符号位 s： 0 代表正数，1代表负数 
阶码字段的长度为 11 位：
    从第 62 位到 52 位，这 11 个二进制位与阶码的值 E 是相关的。
小数字段的长度为 52 位：
    剩余的 52 位与尾数 M 是相关的。

浮点数的数值可以分为三类:第一类是规格化的值，第二类是非规格化的值，第三类是特殊值。
其中阶码的值决定了这个数是属于其中哪一类：
- 阶码字段的二进制位不全为 0，且不全为 1 时，此时表示的是规格化的值
- 阶码字段的二进制位全为 0 时，此时表示的数值是非规格化的值
- 阶码字段的二进制位全为 1 时，表示的数值为特殊值
    - 一类表示无穷大或者无穷小，另外一类表示“不是一个数”

